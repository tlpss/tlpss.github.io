<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://tlpss.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://tlpss.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-01-19T12:56:04+00:00</updated><id>https://tlpss.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Training a real robot to push objects</title><link href="https://tlpss.github.io/blog/2022/urstatepusher-1/" rel="alternate" type="text/html" title="Training a real robot to push objects"/><published>2022-06-20T15:09:00+00:00</published><updated>2022-06-20T15:09:00+00:00</updated><id>https://tlpss.github.io/blog/2022/urstatepusher-1</id><content type="html" xml:base="https://tlpss.github.io/blog/2022/urstatepusher-1/"><![CDATA[<p>Deep reinforcement learning has made tremendous progress over the past years. Algorithmic advances have resulted in more stable learning, less fragility to hyperparameter settings, and some progress in data efficiency. Together with the increase in computing power, this has enabled roboticists to tackle more challenging problems. On the other hand, the field of robot learning is by far not as mature as e.g. computer vision with deep learning, where relatively little knowledge is required to apply state-of-the-art techniques to a custom dataset of interest. Using RL to train a real robot on a manipulation task remains a challenging endeavor.</p> <p>In this tutorial, I will describe how to set up and train a real robot (UR3e) to perform the simple task of <strong>pushing an object to a target position</strong>. You can see the physical setup below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/ur-state-pusher/setup-480.webp 480w,/assets/img/blog/ur-state-pusher/setup-800.webp 800w,/assets/img/blog/ur-state-pusher/setup-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/ur-state-pusher/setup.jpg" class="img-fluid mx-auto d-block rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Roboticists with experience in real-world robot learning will most likely not learn something new from this tutorial. However, <strong>the nuances of real-world robot learning are not always easily available to newcomers in the field as they are scattered across many papers and/or blogposts or just not written down at all</strong>. In this tutorial, I aim to introduce some of these nuances. As we will talk about using RL for real robots, I assume you have some basic knowledge of RL.</p> <p>Training a robot to perform a task (with RL) has two main components. First, you need to define the task at hand: What are the actions the robot can take? What is the input to the control policy (i.e. the observations)? How do we tell the robot it is doing well? In the second stage, you need to select a learning algorithm, find good hyperparameters and train the robot on the task. In the remainder of this blog post, I will discuss the first part. A second blog post will focus on the learning part.</p> <p>To further reduce the complexity of this task, I will make some design choices that simplify it. <strong>These choices make the learning environment less “generic” but are necessary to reduce the required amount of interactions during training</strong>. Many people (including me) are working on improving robot learning to decrease the number of required (real-world) interactions when you want to teach a new task to your robot, so hopefully in a few years these simplifications won’t be necessary anymore.</p> <h2 id="defining-the-task">Defining the Task</h2> <p>As said before, in this post we will dive into defining and implementing the task -pushing a disc to a target position- that we want the robot to solve. I will briefly introduce the mathematical formalism that is used in RL for this task specification, which will bring us to the design decisions we have to make. I will also introduce the commonly used Gym interface. Thereafter we will discuss some issues specific to real-world learning that will influence the design choices. Finally, we will create the learning environment.</p> <h3 id="mdp-formalism">MDP Formalism</h3> <p>in RL, tasks are defined as a <a href="https://en.wikipedia.org/wiki/Markov_decision_process">Markov Decision Process (MDP)</a>. An MDP is often defined as a 5-tuple</p> \[\langle S,A,R,P,\rho_0 \rangle.\] <p>\(S\) is the state space, \(A(s)\) the (state-conditioned) action space, \(R(s,a,s')\) is the reward fucntion, \(P(s'| s,a)\) is the transition function and \(s_0 \sim \rho_0\) is the initial state distribution. So to specify the task we want the robot to learn we need to define</p> <ul> <li>a state space,</li> <li>action space,</li> <li>reward function,</li> <li>and initial distribution.</li> </ul> <p>The transition function is taken care of by the laws of physics (and a couple of abstraction layers).</p> <h3 id="difficulties-with-real-world-robot-learning">Difficulties with real-world robot learning</h3> <p>There are some aspects that make RL for real-world robot learning trickier than say learning to play a video game. These issues are well-known and a.o. discussed in an excellent paper called <a href="https://arxiv.org/pdf/2102.02915.pdf">How to Train Your Robot with DeepRL - Lessons Learned</a>.</p> <p>A first issue is <strong>how to obtain state information</strong>. In games or robotics simulators, we have access to the entire state of the environment but this is no longer true in a real-world setting. In general, there are two options to tackle this:</p> <ol> <li>Instrumentation of the environment.</li> <li>Providing the agent with sensor data instead of the complete state. As the agent now does no longer have access to the exact state, we call this setting a Partial-Observable MDP (POMDP). RGB(D) cameras are by far the most used sensing modality for robots due to their high information density and low cost.</li> </ol> <p>Related to this is <strong>how to compute the rewards for the agent</strong>. The reward function \(r(s,a,s')\) depends on the environment state, which is no longer available. Again one could instrument the environment or try to come up with heuristics such as the difference in sensor space between the goal and current state. Another approach is learning a reward function based on the available sensor inputs. The reward can be learned together with the policy (Inverse RL) or upfront from examples of the desired manipulation behavior.</p> <p>A third issue is related to autonomous operation: we want to minimize the number of human inventions during training. The RL framework assumes that we can <strong>reset the environment</strong> at the end of an <em>episode</em>. Although this is indeed easily done in games of simulators, it is not the case in the real world where it requires instrumenting the environment or scripting reset policies for the robot to execute. Furthermore, some manipulation tasks are irreversible, think about preparing food.</p> <p>Fourthly, in real-world settings, <strong>safety</strong> is also an important factor. We do not want the robot to harm humans or to destroy itself or its environment. This is especially relevant at the beginning of training where the behavior will typically be random.</p> <p>And last but certainly not least, there is the <strong>sample-efficiency</strong>. Even state-of-the-art RL algorithms require a huge number of interactions to learn tasks end-to-end. Usually, the number of samples is <a href="https://arxiv.org/pdf/1801.01290.pdf">expressed in millions</a>. In simulation, this is not an issue as we can easily generate this amount of interactions (or samples). However, collecting one million samples for real robots is a challenging task that requires <a href="https://arxiv.org/pdf/2104.08212.pdf">a lot of resources and engineering skills</a>, and a lot of patience… Say that our robot has a control loop of 20Hz, this means the robot takes 20 decisions each minute and hence collects 1200 samples per hour. To collect 1 million samples, the robot would take about 1 month (!) of non-stop data collection even if it were to operate 24/7, which is highly unlikely. To reduce the number of samples, researchers try to come up with <a href="https://arxiv.org/abs/1806.06920">more efficient algorithms</a>, to introduce <a href="https://arxiv.org/abs/2004.04136">additional loss functions</a> (especially to help train the vision encoder), or to use <a href="https://arxiv.org/abs/2004.14990">data augmentation</a>. Another option is to leverage prior knowledge to formulate the task in a more sample-efficient way instead of learning to map pixels to low-level actions.</p> <h3 id="gym-interface">Gym Interface</h3> <p>The dominant way of implementing the resulting MDP and providing the learning algorithm with an interface to the environment is through a <a href="https://www.gymlibrary.ml/">Gym interface</a>.</p> <p>Interacting with a Gym environment follows the standard agent-environment interaction scheme and goes as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env</span> <span class="o">=</span> <span class="nc">YourEnvironment</span><span class="p">()</span>
<span class="n">observation</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
   <span class="n">action</span> <span class="o">=</span> <span class="nf">policy</span><span class="p">(</span><span class="n">observation</span><span class="p">)</span>  <span class="c1"># User-defined policy function
</span>   <span class="n">observation</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
      <span class="n">observation</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="n">return_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">env</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div> <p>We can now map the task definition aspects that we listed in the previous section to the corresponding implementation tasks in the gym interface.</p> <ul> <li>define observation space -&gt; implement a function to obtain the <code class="language-plaintext highlighter-rouge">observation</code> from the environment, hence implicitly defining the observation space.</li> <li>define action space -&gt; implement a function that makes the robot execute the action if it is part of \(A(s)\), hence implicitly defining the action space.</li> <li>define reward function -&gt; implement function to calculate reward based on the available information.</li> <li>define initial state distribution-&gt; implement a reset function that brings the environment to a state according to the initial state distribution.</li> </ul> <p>One might argue that the control stack of the robot is part of the transition function.. I’ve decided to list it as part of the action space implementation but I’m not so sure this is “correct”, feel free to let me know if you feel that this should be part of the transition function.</p> <h3 id="designing-the-environment">Designing the environment</h3> <p>Now that we have summed up the decisions we need to make and discussed the difficulties of real-world robot learning, we can create the learning environment.</p> <h4 id="hardware">Hardware</h4> <p>The setup that I am using consists of a Universal Robot <a href="https://www.universal-robots.com/products/ur3-robot/">UR3e</a> and a Stereolabs <a href="https://www.stereolabs.com/zed-2i/">Zed2i</a> camera. The object that I want to push to the target location is a disc with a radius of 5cm. To communicate with the UR3e robot, I use the <a href="https://sdurobotics.gitlab.io/ur_rtde/index.html">ur-rtde</a> library, which is a lightweight wrapper around the RTDE interface of the robot. We can easily get the joint states as well as the End-Effector (EEF) pose and can send actions in joint space or in end-effector space (where they are interpreted as linear motions of the EEF). The ZED camera comes with a fantastic SDK. Using the SDK and OpenCV, I created a simple toolkit for all operations that were required for this project. This toolkit is available <a href="https://github.com/tlpss/camera-toolkit">here</a>.</p> <h4 id="observations">Observations</h4> <p>To get the observations, we either need to instrument the environment to obtain the relevant state or use sensor readings as observation, which in this case would be taking images with 1 or more cameras and feeding them to the RL algorithm. I chose the first option as it drastically reduces the input dimensionality of the RL agent and hence the required number of interactions. The relevant state of the environment consists of</p> <ul> <li>the pose of the object,</li> <li>the goal pose</li> <li>and the state of the robot.</li> </ul> <p>Note that this gives a 6-dimensional input, whereas even a low-resolution image of 64x64 would be approx. 600 times larger…</p> <p>Typically we want to express all poses relative to the robot’s base frame or EEF frame. Here I chose to use the base frame, as this best suits the action space I had in mind (this process of creating the environment is by no means linear, even though it is laid out linearly in this post..)</p> <p>The relevant pose of the object reduces to a 2D position as the object that I used is a disk, which is symmetric around the z-axis. To obtain the position I first used a fiducial marker (aruco/charuco/..) to determine the pose of the camera w.r.t. that marker. I then measured the translation from that marker (aligning the marker manually to the robot frame) to the robot base on the table by moving the robot to the marker and querying the EEF pose. Combining these two transformations gives us the pose of the camera w.r.t. the robot.</p> <p><em>This process of getting the camera-robot transform is called hand-eye calibration. There exist tools to solve this such as <a href="https://github.com/ros-planning/moveit_calibration">Moveit_calibration</a> (not yet ported to ROS2) or <a href="https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html#gaebfc1c9f7434196a374c382abf43439b">Opencv</a>. These methods would probably result in better performance as you do not need to eyeball the rotational alignment of the marker with the robot frame, although they are more elaborate and very sensitive to the calibration poses that are collected.</em></p> <p>Now we can determine the pose of an object on the table by determining the position of the object on the image plane of the camera and then projecting the resulting image ray onto the table (or more precisely on the plane at the height of the object, parallel to the table). Below you can find a sketch of the different transforms and the steps to acquire them.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/ur-state-pusher/state-estimation-480.webp 480w,/assets/img/blog/ur-state-pusher/state-estimation-800.webp 800w,/assets/img/blog/ur-state-pusher/state-estimation-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/ur-state-pusher/state-estimation.png" class="mx-auto d-block rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>I’ve used a 5x5 aruco marker of 5cm for the object and a 6x6 Aruco marker of 10cm for the camera calibration (bigger is better). Make sure to use the highest resolution (2K in case of the Zed camera) to limit the reprojection errors. The resulting estimated positions were mostly within 1cm of the object’s true position, which seems accurate enough for this task. However, I’m rather sure that you could increase this accuracy by using a (large) charuco board for determining the camera extrinsics or by using a proper <em>hand-eye calibration</em> tool. One obvious limitation of this method is that it requires the marker to be visible from the camera at all times, however, you can easily see how the robot could occlude the marker whilst interacting with the object. This is something that we will come back to during the action space design.</p> <p><em>Note that the Zed camera is actually a depth camera, so instead of manually reprojecting to a plane parallel to the table we could sample the depth image to get a 3D location. This proved however to be less accurate as we know the exact height in this case. Yet another option would be to use stereoview and find the intersection between the rays, but again if you know the exact height of the object there is no need to do this.</em></p> <p>The target position is typically known to the agent. Furthermore, it was fixed during this experiment to reduce complexity. Nonetheless, it is still included in the observation as my intuition was that this would make the task easier to learn for the network since it would not have to internalize the goal position.</p> <p>As we will soon discuss, I chose my actions in such a way that the robot does not need to know its position, so the observation space reduces to \([\hat{x}_{object},\hat{y}_{object},x_{goal},y_{goal}]\).</p> <p>This is implemented in the following snippet (with an additional try-catch on the aruco marker detection for robustness):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_get_observation</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>  
    <span class="sh">"""</span><span class="s">  
    gym observation 
    </span><span class="sh">"""</span>  
    <span class="n">object_position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_object_position</span><span class="p">()</span>  
  
    <span class="n">obs</span> <span class="o">=</span> <span class="n">object_position</span><span class="p">.</span><span class="nf">tolist</span><span class="p">()</span>  
    <span class="n">obs</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">goal_position</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">obs</span>
   
<span class="k">def</span> <span class="nf">_get_object_position</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>  
    <span class="sh">"""</span><span class="s">  
    Get object pose by reading in image frame, detecting keypoint and reprojecting it on the Z = object_height plane.
    </span><span class="sh">"""</span>  
    <span class="n">img</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="nf">get_mono_rgb_image</span><span class="p">()</span>  
    <span class="n">img</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">camera</span><span class="p">.</span><span class="nf">image_shape_torch_to_opencv</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  
  
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>  
        <span class="n">image_coords</span> <span class="o">=</span> <span class="nf">get_aruco_marker_coords</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">aruco</span><span class="p">.</span><span class="n">DICT_5X5_250</span><span class="p">)</span>  
        <span class="k">if</span> <span class="n">image_coords</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  
                <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Could not detect the aruco marker after 3 attempts. Is the marker visible?</span><span class="sh">"</span><span class="p">)</span>  
            <span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sh">"</span><span class="s">could not detect object aruco marker</span><span class="sh">"</span><span class="p">)</span>  
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>  
        <span class="k">else</span><span class="p">:</span>  
            <span class="k">break</span>  
    <span class="n">aruco_frame_coords</span> <span class="o">=</span> <span class="nf">reproject_to_ground_plane</span><span class="p">(</span>  
        <span class="n">image_coords</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">cam_matrix</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">aruco_in_camera_transform</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">URPushState</span><span class="p">.</span><span class="n">object_height</span>  
    <span class="p">)</span>  
  
    <span class="n">robot_frame_coords</span> <span class="o">=</span> <span class="n">aruco_frame_coords</span> <span class="o">+</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_to_aruco_translation</span>  
  
    <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">position_is_in_object_space</span><span class="p">(</span><span class="n">robot_frame_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]):</span>  <span class="c1"># pushed object outside of goal_space  
</span>        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span>  
            <span class="sh">"</span><span class="s">Object is outside of workspace.. this should not happen and is probably caused</span><span class="sh">"</span>  
            <span class="sh">"</span><span class="s"> by inaccurate object position which makes the primitive motion behave unexpected.</span><span class="sh">"</span>  <span class="p">)</span>  
  
    <span class="k">return</span> <span class="n">robot_frame_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div> <h4 id="episode-termination">Episode Termination</h4> <p>Next to the observation and reward, the <code class="language-plaintext highlighter-rouge">step</code> function also returns whether the episode has terminated or not. This allows the learning algorithm to reset the environment as well as to do some bookkeeping for calculating the expected returns or storing the experiences in a replay buffer. As we consider episodic RL, the episode terminates either if the goal is reached or if the maximum amount of steps has been reached:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@staticmethod</span>  
<span class="k">def</span> <span class="nf">_is_episode_finished</span><span class="p">(</span><span class="n">n_steps_in_episode</span><span class="p">,</span> <span class="n">distance_to_target</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>  
    <span class="n">done</span> <span class="o">=</span> <span class="n">distance_to_target</span> <span class="o">&lt;</span> <span class="n">PushStateConfig</span><span class="p">.</span><span class="n">goal_l2_margin</span>  <span class="c1"># goal reached  
</span>    <span class="n">done</span> <span class="o">=</span> <span class="n">done</span> <span class="ow">or</span> <span class="n">n_steps_in_episode</span> <span class="o">&gt;=</span> <span class="n">PushStateConfig</span><span class="p">.</span><span class="n">max_episode_steps</span>  
    <span class="k">return</span> <span class="n">done</span>
</code></pre></div></div> <h4 id="actions">Actions</h4> <p>Designing the action space was the most tricky part of this project. There are several aspects to keep in mind here:</p> <ul> <li>For the state estimation, the object should not be occluded after a step has been taken (or we should work around occlusions using multiple aruco markers on different sides, etc..).</li> <li>The result of executing an action should be such that the robot can still reach the goal state from that state (Or the environment can at least be reset to an arbitrary initial state) to enable autonomous data collection.</li> <li>Although one of the core elements of RL is its ability to deal with long-horizon tasks with delayed feedback (sparse rewards), in practice it tends to work a lot better with short-horizon tasks and more immediate feedback (dense rewards). This translates into a trend toward formulating robotic (manipulation) problems as short-horizon tasks by using pre-defined motion primitives. An example is grasping objects, where one could have the policy move the EEF (long horizon) or have it determine a grasp location (short horizon) that is then executed by a scripted controller.</li> </ul> <p>The most generic action space would be the 6DOF pose of the gripper and its actuation. However, such an action space would surely result in occlusions of the object now and then. Furthermore, and even more importantly, the robot would often not be in contact with the object during the execution of an action, making exploration a lot harder and requiring more interactions. On the other hand, if we think about the task we know what a good policy should look like: it should push the object (and ideally in the right direction). Using this prior information, I decided to use a “push motion primitive”: The robot will always push the object during the execution of an action, but the agent has to decide how far and in what direction: \((\theta,l)\).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/ur-state-pusher/motion-primitive-480.webp 480w,/assets/img/blog/ur-state-pusher/motion-primitive-800.webp 800w,/assets/img/blog/ur-state-pusher/motion-primitive-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/ur-state-pusher/motion-primitive.png" class="img-fluid.center mx-auto d-block rounded z-depth-1 zoomable=true " width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>In between actions, the robot will lift its EEF, hence avoiding occlusions of the aruco marker. Furthermore, this formulation enables the agent to complete the task with a single action, which gives a very short horizon indeed. Also, during each action, the agent will move the object, which will make it very easy to provide immediate feedback and hence avoid delayed rewards. This will all drastically reduce the required amount of robot interactions.</p> <p>The robot’s workspace is defined by its mechanical design as well as by the control stack that is used for the robot: as I am not using a motion planner, the robot is simply moving linearly in cartesian space. However, this can easily result in collisions with the robot base or other links for poses that are close to the robot base. So I had to manually constrain the workspace of the robot to avoid self-collisions. After some experimenting (and collisions), I arrived at the following “safe” workspace for the robot:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/ur-state-pusher/robot-workspace-480.webp 480w,/assets/img/blog/ur-state-pusher/robot-workspace-800.webp 800w,/assets/img/blog/ur-state-pusher/robot-workspace-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/ur-state-pusher/robot-workspace.png" class="img-fluid mx-auto d-block rounded z-depth-1 " width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>It is important to note that it is not always possible to design such “collision-safe action spaces”. In environments with lots of objects, this would be very hard (and constantly changing). In such scenarios, you should consider using an explicit motion planner (<a href="https://github.com/ros-planning/moveit2">Moveit2</a>) if you know the locations of the obstacles. If you do not know the locations, your robot will inevitably make undesired contact with the environment and you should consider using an (indirect) force controller at the low level to avoid damage. (Such active-compliant controllers are often even better-suited for contact-rich tasks (e.g. insertion tasks) anyway. See <a href="https://arxiv.org/pdf/1906.08880.pdf">this paper</a> for example).</p> <p>To make sure the robot would be able to push the object in at least one direction during the next action, the object’s end position should be no closer than the radius of the object + the radius of the EEF to the border of the robot’s workspace (defined w.r.t. the tool point center or the center of the EEF). Actions that do not meet this constraint are considered invalid and will not be executed by the robot, although the episode will not finish.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/ur-state-pusher/object-space-480.webp 480w,/assets/img/blog/ur-state-pusher/object-space-800.webp 800w,/assets/img/blog/ur-state-pusher/object-space-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/ur-state-pusher/object-space.png" class="img-fluid mx-auto d-block rounded z-depth-1 " width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Note that we can predict the outcome of the primitive for this simple task (we know the dynamics model), although this usually is not the case. We could then stop the action when the robot reaches the edge of its workspace, which we can always detect at runtime if we have access to the proprioceptive state.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_execute_primitive_motion</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  
    <span class="sh">"""</span><span class="s">  
 Do the </span><span class="sh">"</span><span class="s">motion primitive</span><span class="sh">"</span><span class="s">: a push along the desired angle and over the specified distance  
 To avoid collisions this is executed as: - move to pre-start pose - move to start pose - push - move to post-push pose - move to </span><span class="sh">"</span><span class="s">out-of-sight</span><span class="sh">"</span><span class="s"> pose (home)  
  
 angle: radians in [0,2Pi] length: value in [0, max_pushing_distance]  
 Returns True after executing if the motion was allowed (start robot position is in the robot workspace, end object position is in the block workspace) and False otherwise. </span><span class="sh">"""</span>  
 
 <span class="c1"># get current position of the object
</span>    <span class="n">current_object_position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_object_position</span><span class="p">()</span>  
  
    <span class="c1"># determine primitive motion start and endpoint  
</span>    <span class="n">push_direction</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>  
  
    <span class="n">block_start_point</span> <span class="o">=</span> <span class="n">current_object_position</span>  
    <span class="n">robot_start_point</span> <span class="o">=</span> <span class="n">block_start_point</span> <span class="o">-</span> <span class="n">push_direction</span> <span class="o">*</span> <span class="p">(</span>  
        <span class="n">URPushState</span><span class="p">.</span><span class="n">object_radius</span> <span class="o">+</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_flange_radius</span> <span class="o">+</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_motion_margin</span>  
    <span class="p">)</span>  
    <span class="n">block_end_point</span> <span class="o">=</span> <span class="n">block_start_point</span> <span class="o">+</span> <span class="n">length</span> <span class="o">*</span> <span class="n">push_direction</span>  
    <span class="n">robot_end_point</span> <span class="o">=</span> <span class="n">block_end_point</span> <span class="o">-</span> <span class="n">push_direction</span> <span class="o">*</span> <span class="p">(</span>  
        <span class="n">URPushState</span><span class="p">.</span><span class="n">object_radius</span> <span class="o">+</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_flange_radius</span>  
    <span class="p">)</span>  
  
    <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">motion primitive: (angle:</span><span class="si">{</span><span class="n">angle</span><span class="si">}</span><span class="s">,len:</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s"> ) - </span><span class="si">{</span><span class="n">block_start_point</span><span class="si">}</span><span class="s"> -&gt; </span><span class="si">{</span><span class="n">block_end_point</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  
    <span class="c1"># calculate if the proposed primitive does not violate the robot's workspace  
</span>  
  <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">_position_is_in_workspace</span><span class="p">(</span><span class="n">robot_start_point</span><span class="p">):</span>  
        <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">invalid robot startpoint for primitive </span><span class="si">{</span><span class="n">block_start_point</span><span class="si">}</span><span class="s"> -&gt; </span><span class="si">{</span><span class="n">block_end_point</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  
        <span class="k">return</span> <span class="bp">False</span>  
 <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">position_is_in_object_space</span><span class="p">(</span><span class="n">block_end_point</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>  
        <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">invalid  block endpoint for primitive </span><span class="si">{</span><span class="n">block_start_point</span><span class="si">}</span><span class="s"> -&gt; </span><span class="si">{</span><span class="n">block_end_point</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  
        <span class="k">return</span> <span class="bp">False</span>  
  
  <span class="c1"># move to start pose  
</span>  <span class="n">self</span><span class="p">.</span><span class="nf">_move_robot</span><span class="p">(</span><span class="n">robot_start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">robot_start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_eef_z</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">)</span>  
    <span class="c1"># execute  
</span>  <span class="n">self</span><span class="p">.</span><span class="nf">_move_robot</span><span class="p">(</span><span class="n">robot_start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">robot_start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_eef_z</span><span class="p">)</span>  
    <span class="n">self</span><span class="p">.</span><span class="nf">_move_robot</span><span class="p">(</span><span class="n">robot_end_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">robot_end_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_eef_z</span><span class="p">)</span>  
  
    <span class="c1"># move back to home pose  
</span>  <span class="n">self</span><span class="p">.</span><span class="nf">_move_robot</span><span class="p">(</span><span class="n">robot_end_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">robot_end_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_eef_z</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">)</span>  
    <span class="n">self</span><span class="p">.</span><span class="nf">_move_robot</span><span class="p">(</span><span class="n">URPushState</span><span class="p">.</span><span class="n">home_pose</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">home_pose</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">home_pose</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div> <h4 id="resets">Resets</h4> <p>The reset of our environment is fairly simple: we should move the object to a random position within the object space and we’re done. This initial state of our MDP should be uniformly distributed over the object space (with a little extra margin to accommodate for state estimation errors), so I simply used rejection sampling to obtain them:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@staticmethod</span>  
<span class="k">def</span> <span class="nf">get_random_object_position</span><span class="p">(</span><span class="n">goal_position</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>  
    <span class="sh">"""</span><span class="s">  
    Brute-force sample positions until one is in the allowed object workspace </span><span class="sh">"""</span>  
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>  
         <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span>  
         <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">-</span> <span class="mf">0.45</span>  
         <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>  
         <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">proposed object reset </span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  
         <span class="nf">if </span><span class="p">(</span>  
              <span class="n">URPushState</span><span class="p">.</span><span class="nf">_position_is_in_workspace</span><span class="p">(</span>  
                  <span class="n">position</span><span class="p">,</span>  
                   <span class="n">margin</span><span class="o">=</span><span class="mf">1.1</span>  
                      <span class="o">*</span> <span class="p">(</span><span class="n">URPushState</span><span class="p">.</span><span class="n">object_radius</span> <span class="o">+</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_flange_radius</span> <span class="o">+</span> <span class="n">URPushState</span><span class="p">.</span><span class="n">robot_motion_margin</span><span class="p">),</span>  
              <span class="p">)</span>  
          <span class="p">):</span>  
                <span class="k">return</span> <span class="n">position</span>
</code></pre></div></div> <h4 id="rewards">Rewards</h4> <p>We already know the relevant state of the environment (the pose of the object and the goal position) and hence we can simply formulate the reward as $r(s,a,s’)$ instead of having to define it in terms of the available sensor readings.</p> <p>How to come up with an appropriate reward function? This is more of an art than a scientific process, but there are some guidelines to follow. The simplest reward is 1 if the goal is reached and 0 elsewhere. However, these sparse rewards create very hard exploration problems, as the agent needs to solve the complete task by accident (it is taking random actions at that time) before it ever receives any feedback… There exist techniques such as <a href="">Hindsight Experience Replay</a> or <a href="https://libstore.ugent.be/fulltxt/RUG01/003/014/816/RUG01-003014816_2021_0001_AC.pdf">Curriculum learning methods</a> that try to overcome this, but in general, it is more pragmatical to add more information to the reward signal.<br/> An obvious candidate is often to include heuristics for the distance towards the goal. To make sure this so-called reward shaping does not influence the optimal solution of the MDP, you typically want the reward components to be <a href="https://people.eecs.berkeley.edu/~pabbeel/cs287-fa09/readings/NgHaradaRussell-shaping-ICML1999.pdf">potential-based functions</a>. Even then, combining different components can be tricky as you need to carefully balance them. More about the dificulties with combining losses can be found in <a href="https://www.engraved.blog/why-machine-learning-algorithms-are-hard-to-tune/">this excellent blog post</a> by Jonas Degraeve.</p> <p>I settled for the following reward function:</p> \[- \frac{current\_distance}{max\_distance}.\] <p>Note that this is not a potential-based function, but the agent is discouraged from taking any unnecessary action as the reward is negative at each timestep. Also note that I do not additionally punish the robot for taking invalid actions, although I am not sure if this would be beneficial or not (and at what tuning cost for me). If you have some insights on this matter, feel free to let me know!</p> <p>You can see how this reward function provides feedback at every single step, making it a lot easier for the agent to learn.</p> <p>We are now done with the environment setup. The implementation of the <code class="language-plaintext highlighter-rouge">step</code> function now looks as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>  
    <span class="sh">"""</span><span class="s">  
 performs action, returns observation, reward, is episode finished?, info dict (empty) </span><span class="sh">"""</span>  
 
    <span class="n">self</span><span class="p">.</span><span class="n">n_steps_in_episode</span> <span class="o">+=</span> <span class="mi">1</span>  
  
    <span class="n">normalized_angle</span><span class="p">,</span> <span class="n">normalized_length</span> <span class="o">=</span> <span class="n">action</span>  
    <span class="n">angle</span> <span class="o">=</span> <span class="n">normalized_angle</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span>  
    <span class="n">length</span> <span class="o">=</span> <span class="n">normalized_length</span> <span class="o">*</span> <span class="n">PushStateConfig</span><span class="p">.</span><span class="n">max_pushing_distance</span>  
    <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">taking action (</span><span class="si">{</span><span class="n">angle</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">)</span>  
    <span class="n">valid_action</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_execute_primitive_motion</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>  
  
    <span class="n">new_observation</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_observation</span><span class="p">()</span>  
    <span class="n">new_object_position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_object_position</span><span class="p">()</span>  
  
    <span class="n">distance_to_target</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">new_object_position</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">goal_position</span><span class="p">)</span>  
    <span class="n">done</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_is_episode_finished</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n_steps_in_episode</span><span class="p">,</span> <span class="n">distance_to_target</span><span class="p">)</span>  
  
    <span class="c1"># determine reward  
</span>    <span class="n">reward</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">calculate_reward</span><span class="p">(</span><span class="n">valid_action</span><span class="p">,</span> <span class="n">distance_to_target</span><span class="p">)</span>  
  
    <span class="k">return</span> <span class="n">new_observation</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="p">{}</span>
</code></pre></div></div> <p>The next two sections briefly discuss logging and testing, two important yet often overlooked topics..</p> <h3 id="logging">Logging</h3> <p>Logging is important for every robot system. Either to figure out what went wrong or to simply follow along with what the robot is doing. In this environment, I used the built-in <a href="https://realpython.com/python-logging/">python logging</a> framework. I logged resets, actions taken, etc.. During testing, these were printed to the main console for convenience but during training, we can write them to a file to avoid cluttering the CLI. The following snippet shows how to customize what happens to the logged information:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="c1"># configure logging
</span>    <span class="c1"># https://realpython.com/python-logging/#basic-configurations  
</span>    <span class="n">logging</span><span class="p">.</span><span class="nf">basicConfig</span><span class="p">(</span>  
        <span class="n">filename</span><span class="o">=</span><span class="sh">"</span><span class="s">learn.log</span><span class="sh">"</span><span class="p">,</span>  
        <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">INFO</span><span class="p">,</span>  
        <span class="n">filemode</span><span class="o">=</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span>  
        <span class="nb">format</span><span class="o">=</span><span class="sh">"</span><span class="s">%(asctime)s - %s(name) - %(levelname)s - %(message)s</span><span class="sh">"</span><span class="p">,</span>  
        <span class="n">datefmt</span><span class="o">=</span><span class="sh">"</span><span class="s">%d-%b-%y %H:%M:%S</span><span class="sh">"</span><span class="p">,</span>  
    <span class="p">)</span>
    
    <span class="c1"># learning stuff
</span>    <span class="c1"># ...
</span></code></pre></div></div> <p>The logs proved to be invaluable both during testing and training, as it was not always easy to see when the robot was doing a “stupid action” or was simply resetting the environment. I also found it convenient to display the logging information on a screen next to the robot. For a more involved project, I would take some time to create a dedicated information window next to the robot, containing information such as the episode step, the real-world training time, the action taken, etc. I recently discovered <a href="https://github.com/Delgan/loguru">Loguru</a>, which claims to make logging in python even more convenient. Give it a try!</p> <h3 id="testing">Testing</h3> <p>At this point, we have an environment that we can interact with. Before starting to learn there a few sanity checks we can (and should) perform.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/ur-state-pusher/robot-primitive-480.webp 480w,/assets/img/blog/ur-state-pusher/robot-primitive-800.webp 800w,/assets/img/blog/ur-state-pusher/robot-primitive-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/blog/ur-state-pusher/robot-primitive.gif" class="mx-auto d-block rounded z-depth-1 " width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>Although I took care of designing the action space so that the object’s new position was still reachable by the robot, it is a good idea to test what happens when performing random actions:</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_episodes</span><span class="p">):</span>  
    <span class="n">obs</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>  
    <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>  
    <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>  
            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span>  
            <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span>  
            <span class="n">action</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle</span><span class="p">,</span> <span class="n">length</span><span class="p">]</span>  
            <span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>  
            <span class="nf">print</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
</code></pre></div></div> <p>The robot should be able to continue interacting with the environment. However, after a few steps, an error was thrown as the object got out of the object space. After some messing around I found out this was due to imperfect state estimations, resulting in drift during the execution of the motion primitive. Luckily this seemed to be a rare event.</p> <ul> <li>The second check involves scripting a policy and seeing how this one behaves. Usually, this won’t be possible of course, but if you can it is very insightful and a valuable baseline to compare the performance of the learned policy later on. For the task, we are considering, and given the state information it is easy to script a policy (which we already did for resetting the object):</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_calculate_optimal_primitive</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>  
    <span class="sh">"""</span><span class="s">  
    Calculate the optimal angle and length assuming perfect     observation. </span><span class="sh">"""</span> 
    <span class="n">current_position</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get_object_position</span><span class="p">()</span>  
    <span class="n">vector</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="n">current_position</span>  
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arctan2</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
    <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>  
  
    <span class="c1"># from [-pi,pi ] to [0,2pi] for normalization  
</span>    <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  
        <span class="n">angle</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span>  
    <span class="k">return</span> <span class="n">angle</span><span class="p">,</span> <span class="n">length</span>
</code></pre></div></div> <p>This policy performed rather well, although it was already notable that state estimation errors resulted in suboptimal behavior.</p> <p>So now that we have defined the task and tested the implementation, we are ready to start learning! This will be discussed in part 2. The complete code can be found <a href="https://github.com/tlpss/ur-gym/blob/a0d2b97b3ab6facb9d07d258e92f422f23ffe614/ur_gym/pusher/state_pusher.py">here</a> for reference.</p> <p>Thanks for reading, I hope you found it interesting! Feel free to get in touch if you want to discuss something related to setting up environments for real-world robot learning (or just related to robot learnign in general)!</p> <p>also want to thank Andreas Verleysen, for providing valuable feedback on this post.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[In this series, I document how I taught our UR3e robot to push objects to a target position. Part one focuses on creating the learning environment for in-vivo learning.]]></summary></entry></feed>